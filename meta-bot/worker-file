var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/security.ts
async function verifyMetaSignatureOrThrow(req, appSecret, rawBody) {
  const signature = req.headers.get("X-Hub-Signature-256");
  if (!signature) {
    throw new Error("Missing X-Hub-Signature-256 header");
  }
  const encoder = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    encoder.encode(appSecret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signatureBuffer = await crypto.subtle.sign("HMAC", key, rawBody);
  const hashArray = Array.from(new Uint8Array(signatureBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  const expectedSignature = `sha256=${hashHex}`;
  if (!timingSafeEqual(signature, expectedSignature)) {
    throw new Error("Invalid signature");
  }
}
__name(verifyMetaSignatureOrThrow, "verifyMetaSignatureOrThrow");
function timingSafeEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }
  return result === 0;
}
__name(timingSafeEqual, "timingSafeEqual");

// src/meta.ts
var META_SEND_API_URL = "https://graph.facebook.com/v19.0/me/messages";
async function sendTextMessage(psid, text, pageAccessToken) {
  const url = `${META_SEND_API_URL}?access_token=${encodeURIComponent(pageAccessToken)}`;
  const payload = {
    messaging_type: "RESPONSE",
    recipient: {
      id: psid
    },
    message: {
      text
    }
  };
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Meta Send API error: ${response.status} ${errorText}`);
  }
}
__name(sendTextMessage, "sendTextMessage");

// src/supabase.ts
var SupabaseRepo = class {
  static {
    __name(this, "SupabaseRepo");
  }
  constructor(url, serviceKey) {
    this.url = url;
    this.serviceKey = serviceKey;
  }
  /**
   * Get headers for Supabase requests
   */
  headers() {
    return {
      "apikey": this.serviceKey,
      "Authorization": `Bearer ${this.serviceKey}`,
      "Content-Type": "application/json",
      "Prefer": "return=representation"
    };
  }
  /**
   * Upsert lead by PSID (creates if not exists, updates last_seen_at if exists)
   */
  async upsertLeadByPsid(psid) {
    const endpoint = `${this.url}/rest/v1/bot_leads?on_conflict=psid&select=*`;
    const body = [{
      psid,
      status: "active",
      last_seen_at: (/* @__PURE__ */ new Date()).toISOString()
    }];
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        ...this.headers(),
        "Prefer": "resolution=merge-duplicates,return=representation"
      },
      body: JSON.stringify(body)
    });
    if (!res.ok) throw new Error(`Failed to upsert lead: ${res.status} ${await res.text()}`);
    const rows = await res.json();
    if (!rows?.[0]) throw new Error("upsertLeadByPsid: no row returned");
    return rows[0];
  }
  /**
   * Get lead by ID
   */
  async getLeadById(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}&select=*`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to get lead: ${response.status} ${await response.text()}`);
    }
    const leads = await response.json();
    if (leads.length === 0) {
      throw new Error(`Lead not found: ${leadId}`);
    }
    return leads[0];
  }
  /**
   * Set lead status
   */
  async setLeadStatus(leadId, status) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({ status })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to set lead status: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Disable bot for a lead (allows human takeover)
   */
  async disableBot(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({ bot_enabled: false })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to disable bot: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Enable bot for a lead (re-enable automated responses)
   */
  async enableBot(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({ bot_enabled: true })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to enable bot: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Try to claim booking slot atomically (NEW FLOW: claim → collect → book)
   * This ONLY sets pending fields, does NOT create calendar event yet
   * @returns claimed lead row if successful, null if slot unavailable
   */
  async tryClaimPendingSlot(leadId, slot) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}&booked_event_id=is.null`,
      {
        method: "PATCH",
        headers: {
          ...this.headers(),
          "Prefer": "return=representation"
        },
        body: JSON.stringify({
          pending_slot_label: slot.label,
          pending_slot_start: slot.startISO,
          pending_slot_end: slot.endISO,
          pending_claimed_at: (/* @__PURE__ */ new Date()).toISOString(),
          status: "active"
          // Keep as active until finalized
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to claim pending slot: ${response.status} ${await response.text()}`);
    }
    const updated = await response.json();
    return Array.isArray(updated) && updated.length > 0 ? updated[0] : null;
  }
  /**
   * Get pending slot for a lead
   * @returns pending slot info or null if no pending slot
   */
  async getPendingSlot(leadId) {
    const lead = await this.getLeadById(leadId);
    if (!lead.pending_slot_label || !lead.pending_slot_start || !lead.pending_slot_end) {
      return null;
    }
    if (lead.pending_claimed_at) {
      const claimedAt = new Date(lead.pending_claimed_at);
      const now = /* @__PURE__ */ new Date();
      const ageMinutes = (now.getTime() - claimedAt.getTime()) / (1e3 * 60);
      if (ageMinutes > 15) {
        console.log(`[PENDING] Claim expired (${ageMinutes.toFixed(1)} minutes old)`);
        return null;
      }
    }
    return {
      label: lead.pending_slot_label,
      startISO: lead.pending_slot_start,
      endISO: lead.pending_slot_end,
      claimedAt: lead.pending_claimed_at || (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Finalize booking: create calendar event and update lead
   * This is called AFTER collecting all customer details (address and phone only)
   */
  async finalizeBookingWithDetails(leadId, eventId, details) {
    const lead = await this.getLeadById(leadId);
    if (!lead.pending_slot_label || !lead.pending_slot_start || !lead.pending_slot_end) {
      throw new Error("No pending slot to finalize");
    }
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          status: "booked",
          booked_event_id: eventId,
          booked_slot_label: lead.pending_slot_label,
          booked_slot_start: lead.pending_slot_start,
          booked_slot_end: lead.pending_slot_end,
          customer_name: null,
          // No longer collecting name
          customer_address: details.address,
          customer_phone: details.phone,
          // Clear pending fields
          pending_slot_label: null,
          pending_slot_start: null,
          pending_slot_end: null,
          pending_claimed_at: null
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to finalize booking: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Release pending slot claim (if user abandons or slot becomes unavailable)
   */
  async releasePendingClaim(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          status: "active",
          pending_slot_label: null,
          pending_slot_start: null,
          pending_slot_end: null,
          pending_claimed_at: null
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to release pending claim: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * OLD METHOD: Try to claim booking slot atomically (DEPRECATED - use tryClaimPendingSlot)
   * @deprecated Use tryClaimPendingSlot() for new collect-then-book flow
   * @returns claimed lead row if successful, null if already booked
   */
  async tryClaimBooking(leadId, slot) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}&booked_event_id=is.null&status=neq.booked`,
      {
        method: "PATCH",
        headers: {
          ...this.headers(),
          "Prefer": "return=representation"
        },
        body: JSON.stringify({
          status: "booked",
          booked_slot_label: slot.label,
          booked_slot_start: slot.startISO,
          booked_slot_end: slot.endISO
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to claim booking: ${response.status} ${await response.text()}`);
    }
    const updated = await response.json();
    return Array.isArray(updated) && updated.length > 0 ? updated[0] : null;
  }
  /**
   * Finalize booking with event ID
   */
  async finalizeBooking(leadId, eventId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          booked_event_id: eventId
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to finalize booking: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Release booking claim (if staleness check fails)
   */
  async releaseBookingClaim(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          status: "active",
          booked_slot_label: null,
          booked_slot_start: null,
          booked_slot_end: null,
          booked_event_id: null
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to release claim: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Update lead with customer details (name, address, phone)
   */
  async updateLeadDetails(leadId, details) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          customer_name: details.name,
          customer_address: details.address,
          customer_phone: details.phone
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to update lead details: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Mark lead as booked with event details
   */
  async markBooked(leadId, booking) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_leads?id=eq.${leadId}`,
      {
        method: "PATCH",
        headers: this.headers(),
        body: JSON.stringify({
          status: "booked",
          ...booking
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to mark booked: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Insert inbound message
   */
  async insertInboundMessage(leadId, text, raw) {
    const response = await fetch(`${this.url}/rest/v1/bot_messages`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({
        lead_id: leadId,
        direction: "inbound",
        text,
        raw
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to insert inbound message: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Insert outbound message
   */
  async insertOutboundMessage(leadId, text, raw) {
    const response = await fetch(`${this.url}/rest/v1/bot_messages`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({
        lead_id: leadId,
        direction: "outbound",
        text,
        raw
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to insert outbound message: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Get conversation state for a lead
   */
  async getConvoState(leadId) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_convo_state?lead_id=eq.${leadId}&select=*`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to get convo state: ${response.status} ${await response.text()}`);
    }
    const states = await response.json();
    return states.length > 0 ? states[0] : null;
  }
  /**
   * Upsert conversation state
   */
  async upsertConvoState(leadId, step, context) {
    const response = await fetch(`${this.url}/rest/v1/bot_convo_state`, {
      method: "POST",
      headers: {
        ...this.headers(),
        "Prefer": "resolution=merge-duplicates,return=representation"
      },
      body: JSON.stringify({
        lead_id: leadId,
        step,
        context
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to upsert convo state: ${response.status} ${await response.text()}`);
    }
    const states = await response.json();
    return states[0];
  }
  /**
   * Try to insert dedupe record
   * @returns true if already exists (duplicate), false if newly inserted
   */
  async tryInsertDedupe(messageId, leadId) {
    const response = await fetch(`${this.url}/rest/v1/bot_message_dedupe`, {
      method: "POST",
      headers: {
        ...this.headers(),
        "Prefer": "resolution=ignore-duplicates"
      },
      body: JSON.stringify({
        message_id: messageId,
        lead_id: leadId
      })
    });
    if (response.status === 201) {
      return false;
    }
    if (response.status === 200) {
      const body = await response.text();
      return body === "" || body === "[]";
    }
    throw new Error(`Failed to insert dedupe: ${response.status} ${await response.text()}`);
  }
  // ============================================================================
  // PHASE 2: Conversation History
  // ============================================================================
  /**
   * Save message to conversation history
   */
  async saveConversationHistory(leadId, role, content, metadata = {}) {
    const response = await fetch(`${this.url}/rest/v1/bot_conversation_history`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({
        lead_id: leadId,
        role,
        content,
        metadata
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to save conversation history: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  /**
   * Load conversation history (last N messages)
   */
  async loadConversationHistory(leadId, limit = 10) {
    const response = await fetch(
      `${this.url}/rest/v1/bot_conversation_history?lead_id=eq.${leadId}&select=role,content,created_at&order=created_at.desc&limit=${limit}`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to load conversation history: ${response.status} ${await response.text()}`);
    }
    const history = await response.json();
    return history.reverse();
  }
  // ============================================================================
  // PHASE 3: Intent Detection
  // ============================================================================
  /**
   * Save detected intent
   */
  async saveIntent(leadId, messageText, detectedIntent, confidence = null, metadata = {}) {
    const response = await fetch(`${this.url}/rest/v1/bot_intents`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({
        lead_id: leadId,
        message_text: messageText,
        detected_intent: detectedIntent,
        confidence,
        metadata
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to save intent: ${response.status} ${await response.text()}`);
    }
    await response.text();
  }
  // ============================================================================
  // PHASE 4: FAQ Knowledge Base
  // ============================================================================
  /**
   * Load relevant FAQs based on keywords
   */
  async loadRelevantFAQs(keywords) {
    const keywordFilter = keywords.map((k) => `keywords.cs.{${k}}`).join(",");
    const response = await fetch(
      `${this.url}/rest/v1/bot_faq_knowledge?active=eq.true&or=(${keywordFilter})&select=question,answer,category&order=priority.desc&limit=5`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      if (response.status === 404) return [];
      throw new Error(`Failed to load FAQs: ${response.status} ${await response.text()}`);
    }
    return await response.json();
  }
  /**
   * Load all active FAQs
   */
  async loadAllFAQs() {
    const response = await fetch(
      `${this.url}/rest/v1/bot_faq_knowledge?active=eq.true&select=question,answer,category&order=priority.desc`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to load all FAQs: ${response.status} ${await response.text()}`);
    }
    return await response.json();
  }
  // ============================================================================
  // PHASE 5: Analytics
  // ============================================================================
  /**
   * Track analytics event
   */
  async trackEvent(leadId, eventType, eventData = {}) {
    const response = await fetch(`${this.url}/rest/v1/bot_analytics`, {
      method: "POST",
      headers: this.headers(),
      body: JSON.stringify({
        lead_id: leadId,
        event_type: eventType,
        event_data: eventData
      })
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Failed to track event: ${response.status} ${errorText}`);
      return;
    }
    await response.text();
  }
  /**
   * Get active service addons from database
   * Returns all active addons with pricing information
   */
  async getActiveAddons() {
    const response = await fetch(
      `${this.url}/rest/v1/add_ons?is_active=eq.true&select=*&order=name.asc`,
      {
        method: "GET",
        headers: this.headers()
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to get addons: ${response.status} ${await response.text()}`);
    }
    return await response.json();
  }
};

// src/google.ts
function dedupeSlots(slots) {
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const s of slots) {
    const key = `${s.startISO}|${s.endISO}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(s);
  }
  return out;
}
__name(dedupeSlots, "dedupeSlots");
var GoogleCalendar = class {
  constructor(env) {
    this.accessToken = null;
    this.calendarId = env.GOOGLE_CALENDAR_ID;
    this.clientId = env.GOOGLE_CLIENT_ID;
    this.clientSecret = env.GOOGLE_CLIENT_SECRET;
    this.refreshToken = env.GOOGLE_REFRESH_TOKEN;
    this.timeZone = env.GOOGLE_TIMEZONE;
  }
  static {
    __name(this, "GoogleCalendar");
  }
  /**
   * Get access token (refresh if needed)
   */
  async getAccessToken() {
    if (this.accessToken) {
      return this.accessToken;
    }
    const response = await fetch("https://oauth2.googleapis.com/token", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: new URLSearchParams({
        client_id: this.clientId,
        client_secret: this.clientSecret,
        refresh_token: this.refreshToken,
        grant_type: "refresh_token"
      })
    });
    if (!response.ok) {
      throw new Error(`Failed to refresh token: ${response.status} ${await response.text()}`);
    }
    const data = await response.json();
    this.accessToken = data.access_token;
    return this.accessToken;
  }
  /**
   * Query FreeBusy API for busy blocks
   */
  async freeBusy(timeMinISO, timeMaxISO) {
    const token = await this.getAccessToken();
    const response = await fetch(
      "https://www.googleapis.com/calendar/v3/freeBusy",
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          timeMin: timeMinISO,
          timeMax: timeMaxISO,
          items: [{ id: this.calendarId }]
        })
      }
    );
    if (!response.ok) {
      throw new Error(`FreeBusy API error: ${response.status} ${await response.text()}`);
    }
    const data = await response.json();
    const calendar = data.calendars?.[this.calendarId];
    if (!calendar || !calendar.busy) {
      return [];
    }
    return calendar.busy.map((block) => ({
      start: block.start,
      end: block.end
    }));
  }
  /**
   * Check if a specific slot is still free
   */
  async isSlotStillFree(slot) {
    const busyBlocks = await this.freeBusy(slot.startISO, slot.endISO);
    for (const busy of busyBlocks) {
      if (this.overlapsStrings(slot.startISO, slot.endISO, busy.start, busy.end)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Create a calendar event using slot's full 3-hour window
   * @returns Event ID
   */
  async createEvent(slot, summary, description) {
    const token = await this.getAccessToken();
    const response = await fetch(
      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(this.calendarId)}/events`,
      {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          summary,
          description,
          start: {
            dateTime: slot.startISO,
            timeZone: this.timeZone
          },
          end: {
            dateTime: slot.endISO,
            timeZone: this.timeZone
          }
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to create event: ${response.status} ${await response.text()}`);
    }
    const event = await response.json();
    return event.id;
  }
  /**
   * Update a calendar event's description
   * @returns Updated event ID
   */
  async updateEventDescription(eventId, description) {
    const token = await this.getAccessToken();
    const response = await fetch(
      `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(this.calendarId)}/events/${encodeURIComponent(eventId)}`,
      {
        method: "PATCH",
        headers: {
          "Authorization": `Bearer ${token}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          description
        })
      }
    );
    if (!response.ok) {
      throw new Error(`Failed to update event: ${response.status} ${await response.text()}`);
    }
    await response.json();
  }
  /**
   * Generate two available slots using FIXED windows (12-3 PM and 3-6 PM)
   * Tries daysPrimary first, falls back to daysFallback if needed
   * @param timezone - Target timezone
   * @param options - Search options
   * @param forcedDate - Optional: Force search to specific date only
   * @param startOffset - Number of days to skip from today (default: 3 to skip today + next 2 days)
   */
  async generateTwoSlots(timezone, options, forcedDate, startOffset = 3) {
    if (forcedDate) {
      console.log(`[GCAL] Forced date search: ${forcedDate.toISOString()}`);
      const dateSlots = await this.generateSlotsForSpecificDate(forcedDate);
      if (dateSlots.length >= 2) {
        return dedupeSlots(dateSlots).slice(0, 2);
      }
      if (dateSlots.length === 1) {
        console.log(`[GCAL] Only 1 slot on requested date, searching forward for 2nd slot`);
        const { y, m, d } = this.ymdInTZ(forcedDate, this.timeZone);
        for (let i = 1; i <= 14 && dateSlots.length < 2; i++) {
          const nextDay = new Date(Date.UTC(y, m - 1, d + i, 12, 0, 0));
          const nextSlots = await this.generateSlotsForSpecificDate(nextDay);
          if (nextSlots.length > 0) {
            dateSlots.push(nextSlots[0]);
            console.log(`[GCAL] Added 2nd slot from next available day: ${nextSlots[0].label}`);
            break;
          }
        }
      }
      return dedupeSlots(dateSlots).slice(0, 2);
    }
    let slots = await this.generateTwoSlotsFixedWindows(options.daysPrimary, [], 999, startOffset);
    if (slots.length >= 2) {
      return dedupeSlots(slots).slice(0, 2);
    }
    slots = await this.generateTwoSlotsFixedWindows(options.daysFallback, [], 999, startOffset);
    return dedupeSlots(slots).slice(0, 2);
  }
  /**
   * Generate slots for a specific date only
   * Used when user requests explicit date like "the 17th"
   */
  async generateSlotsForSpecificDate(targetDate) {
    const { y, m, d } = this.ymdInTZ(targetDate, this.timeZone);
    console.log(`[GCAL] Searching specific date: ${y}-${m}-${d}`);
    const dayStart = this.makeDateInTZ(this.timeZone, y, m, d, 0, 0);
    const dayEnd = this.makeDateInTZ(this.timeZone, y, m, d, 23, 59);
    const busy = await this.freeBusy(dayStart.toISOString(), dayEnd.toISOString());
    console.log(`[GCAL] Found ${busy.length} busy blocks for ${y}-${m}-${d}`);
    const now = /* @__PURE__ */ new Date();
    const out = [];
    const s1 = this.makeDateInTZ(this.timeZone, y, m, d, 12, 0);
    const e1 = this.makeDateInTZ(this.timeZone, y, m, d, 15, 0);
    const s2 = this.makeDateInTZ(this.timeZone, y, m, d, 15, 0);
    const e2 = this.makeDateInTZ(this.timeZone, y, m, d, 18, 0);
    const candidates = [
      { start: s1, end: e1 },
      { start: s2, end: e2 }
    ].filter((c) => c.end > now);
    for (const c of candidates) {
      const isBusy = busy.some(
        (b) => this.overlapsDates(c.start, c.end, new Date(b.start), new Date(b.end))
      );
      if (!isBusy) {
        const slot = {
          label: this.formatSlotLabel(c.start),
          startISO: c.start.toISOString(),
          endISO: c.end.toISOString()
        };
        console.log(`[GCAL] \u2705 Available on requested date: ${slot.label}`);
        out.push(slot);
      } else {
        const slot = {
          label: this.formatSlotLabel(c.start),
          startISO: c.start.toISOString(),
          endISO: c.end.toISOString()
        };
        console.log(`[GCAL] \u274C Busy on requested date: ${slot.label}`);
      }
    }
    console.log(`[GCAL] Found ${out.length} available slots on requested date`);
    return out;
  }
  /**
   * Generate slots using ONLY fixed 3-hour windows: 12-3 PM and 3-6 PM
   * Made public to allow targeted day searches
   * @param days - Number of days to search forward
   * @param excludeDays - Optional array of day names to exclude (e.g., ['friday', 'saturday'])
   * @param maxSlots - Maximum number of slots to return (default: unlimited for searching)
   * @param startOffset - Number of days to skip from today (default: 0)
   */
  async generateTwoSlotsFixedWindows(days, excludeDays = [], maxSlots = 999, startOffset = 0) {
    const now = /* @__PURE__ */ new Date();
    const startYMD = this.ymdInTZ(now, this.timeZone);
    const rangeStart = this.makeDateInTZ(this.timeZone, startYMD.y, startYMD.m, startYMD.d + startOffset, 0, 0);
    const rangeEnd = new Date(rangeStart.getTime() + days * 24 * 60 * 60 * 1e3);
    console.log(`[GCAL] Searching ${days} days from ${rangeStart.toISOString()} to ${rangeEnd.toISOString()}`);
    console.log(`[GCAL] Excluding days:`, excludeDays);
    const busy = await this.freeBusy(rangeStart.toISOString(), rangeEnd.toISOString());
    console.log(`[GCAL] Found ${busy.length} busy blocks`);
    const out = [];
    const allSlots = [];
    for (let i = 0; i < days; i++) {
      const day = new Date(rangeStart.getTime() + i * 24 * 60 * 60 * 1e3);
      const { y, m, d } = this.ymdInTZ(day, this.timeZone);
      const dayName = new Intl.DateTimeFormat("en-US", {
        weekday: "long",
        timeZone: this.timeZone
      }).format(day).toLowerCase();
      if (excludeDays.includes(dayName)) {
        console.log(`[GCAL] Skipping ${dayName} (excluded)`);
        continue;
      }
      const s1 = this.makeDateInTZ(this.timeZone, y, m, d, 12, 0);
      const e1 = this.makeDateInTZ(this.timeZone, y, m, d, 15, 0);
      const s2 = this.makeDateInTZ(this.timeZone, y, m, d, 15, 0);
      const e2 = this.makeDateInTZ(this.timeZone, y, m, d, 18, 0);
      const candidates = [
        { start: s1, end: e1 },
        { start: s2, end: e2 }
      ].filter((c) => c.end > now);
      for (const c of candidates) {
        const isBusy = busy.some(
          (b) => this.overlapsDates(c.start, c.end, new Date(b.start), new Date(b.end))
        );
        const slot = {
          label: this.formatSlotLabel(c.start),
          startISO: c.start.toISOString(),
          endISO: c.end.toISOString()
        };
        allSlots.push({ day: dayName, slot, isBusy });
        const isDuplicate = out.some(
          (s) => s.startISO === slot.startISO && s.endISO === slot.endISO
        );
        if (!isBusy && !isDuplicate && out.length < maxSlots) {
          console.log(`[GCAL] \u2705 Available: ${slot.label}`);
          out.push(slot);
        } else if (isBusy) {
          console.log(`[GCAL] \u274C Busy: ${slot.label}`);
        } else if (isDuplicate) {
          console.log(`[GCAL] \u26A0\uFE0F Duplicate (skipped): ${slot.label}`);
        }
        if (out.length >= maxSlots) break;
      }
      if (out.length >= maxSlots) break;
    }
    console.log(`[GCAL] Generated ${out.length} available slots`);
    return dedupeSlots(out);
  }
  /**
   * Get year/month/day in target timezone
   */
  ymdInTZ(date, timeZone) {
    const parts = new Intl.DateTimeFormat("en-US", {
      timeZone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).formatToParts(date);
    const get = /* @__PURE__ */ __name((t) => parts.find((p) => p.type === t)?.value ?? "00", "get");
    return { y: +get("year"), m: +get("month"), d: +get("day") };
  }
  /**
   * Build a Date that represents a wall-clock time in the target timeZone
   * FIXED: Properly converts local timezone time to UTC
   */
  makeDateInTZ(timeZone, y, m, d, hh, mm) {
    const localStr = `${y}-${String(m).padStart(2, "0")}-${String(d).padStart(2, "0")}T${String(hh).padStart(2, "0")}:${String(mm).padStart(2, "0")}:00`;
    const utcDate = /* @__PURE__ */ new Date(`${localStr}Z`);
    const formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    });
    const parts = formatter.formatToParts(utcDate);
    const tzHour = parseInt(parts.find((p) => p.type === "hour")?.value || "0");
    const offsetHours = hh - tzHour;
    return new Date(Date.UTC(y, m - 1, d, hh + offsetHours, mm, 0));
  }
  /**
   * Format slot label as "Weekday at HH:MM AM/PM"
   * Shows start time of the 3-hour window (12:00 PM or 3:00 PM)
   */
  formatSlotLabel(date) {
    const formatter = new Intl.DateTimeFormat("en-US", {
      weekday: "long",
      hour: "numeric",
      minute: "2-digit",
      timeZone: this.timeZone
    });
    const parts = formatter.formatToParts(date);
    const weekday = parts.find((p) => p.type === "weekday")?.value || "";
    const hour = parts.find((p) => p.type === "hour")?.value || "";
    const minute = parts.find((p) => p.type === "minute")?.value || "";
    const dayPeriod = parts.find((p) => p.type === "dayPeriod")?.value || "";
    return `${weekday} at ${hour}:${minute} ${dayPeriod}`;
  }
  /**
   * Check if two time ranges overlap (Date objects)
   */
  overlapsDates(s1, e1, s2, e2) {
    return s1 < e2 && s2 < e1;
  }
  /**
   * Check if two time ranges overlap (ISO strings)
   */
  overlapsStrings(start1, end1, start2, end2) {
    const s1 = new Date(start1).getTime();
    const e1 = new Date(end1).getTime();
    const s2 = new Date(start2).getTime();
    const e2 = new Date(end2).getTime();
    return s1 < e2 && s2 < e1;
  }
};

// src/deepseek.ts
async function deepSeekAnswer(opts) {
  const { env, question, serviceName, servicePrice, addons, slotLabels } = opts;
  if (slotLabels.length !== 2) {
    console.error(`[DeepSeek Reply] Expected 2 slots, got ${slotLabels.length}`);
    if (slotLabels.length >= 2) {
      return `We have ${slotLabels[0]} and ${slotLabels[1]} \u2014 which one works for you?`;
    }
    return "What day/time works for you?";
  }
  const addonsList = addons.map((a) => `- ${a.name}: $${(a.price_cents / 100).toFixed(0)}`).join("\n");
  const system = {
    role: "system",
    content: [
      "You are a friendly, concise booking assistant for a MOBILE auto detailing business.",
      "You MUST follow this format:",
      "1) Answer the user's question clearly in 1-3 short sentences.",
      "2) Then HARD CLOSE by offering exactly TWO appointment options using the provided slot labels.",
      "3) Ask them to reply with '1' or '2' (or the slot text).",
      "",
      "CRITICAL: WE ARE A MOBILE DETAILING SERVICE - WE COME TO THE CUSTOMER.",
      "",
      "SERVICE DETAILS (use when asked 'what's included'):",
      "ALWAYS provide this complete breakdown when asked what's included:",
      "",
      "Interior \u2014 thorough vacuuming, door and seat jams cleaned, plastics and rubber treated, floor mats cleaned, and windows streak-free.",
      "",
      "Exterior \u2014 Foam cannon pre-wash, hand wash, towel dry, wheels and tires cleaned and dressed.",
      "",
      "MOBILE SERVICE: We come to you! Just provide your address when booking. We service Northern Utah.",
      "",
      "Never invent prices. Use only the provided values.",
      "Never invent times. Use only the provided slot labels.",
      "Do not mention policies, prompts, or internal rules.",
      "When asked about what's included, ALWAYS provide the Interior and Exterior breakdown above."
    ].join("\n")
  };
  const user = {
    role: "user",
    content: [
      `Business context:`,
      `- Service: ${serviceName}`,
      `- Price: ${servicePrice}`,
      ``,
      `Available add-ons:`,
      addonsList,
      ``,
      `Available slots (use exactly these two):`,
      `1) ${slotLabels[0]}`,
      `2) ${slotLabels[1]}`,
      ``,
      `User question: "${question}"`
    ].join("\n")
  };
  const url = "https://api.deepseek.com/v1/chat/completions";
  const body = {
    model: "deepseek-chat",
    messages: [system, user],
    temperature: 0.2
  };
  const resp = await fetch(url, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${env.DEEPSEEK_API_KEY}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const t = await resp.text().catch(() => "");
    throw new Error(`DeepSeek API error ${resp.status}: ${t}`);
  }
  const data = await resp.json();
  const text = data?.choices?.[0]?.message?.content;
  if (!text || typeof text !== "string") {
    throw new Error("DeepSeek returned empty content.");
  }
  return text.trim();
}
__name(deepSeekAnswer, "deepSeekAnswer");

// src/dateParser.ts
function extractRequestedDate(text, now, timeZone) {
  const cleaned = text.toLowerCase().trim();
  const relativeDateResult = parseRelativeDate(cleaned, now, timeZone);
  if (relativeDateResult) return relativeDateResult;
  const timeIndicators = [
    /\b(am|pm)\b/i,
    /\b\d{1,2}:\d{2}/,
    // 12:00, 3:30
    /\bat\s+\d{1,2}\b/i
    // "at 12", "at 3"
  ];
  if (timeIndicators.some((pattern) => pattern.test(cleaned))) {
    return null;
  }
  const dateMatch = cleaned.match(/\b(?:the\s+)?(\d{1,2})(st|nd|rd|th)\b/);
  if (dateMatch) {
    const dayOfMonth = parseInt(dateMatch[1], 10);
    if (dayOfMonth >= 1 && dayOfMonth <= 31) {
      return parseDateNumber(dayOfMonth, cleaned, now, timeZone);
    }
  }
  const monthNames = [
    "january",
    "february",
    "march",
    "april",
    "may",
    "june",
    "july",
    "august",
    "september",
    "october",
    "november",
    "december"
  ];
  for (let i = 0; i < monthNames.length; i++) {
    if (cleaned.includes(monthNames[i])) {
      const numberMatch = cleaned.match(/\b(\d{1,2})\b/);
      if (numberMatch) {
        const dayOfMonth = parseInt(numberMatch[1], 10);
        if (dayOfMonth >= 1 && dayOfMonth <= 31) {
          return parseDateNumber(dayOfMonth, cleaned, now, timeZone);
        }
      }
    }
  }
  const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  for (const dayName of dayNames) {
    if (cleaned.includes(dayName)) {
      const numberMatch = cleaned.match(/\b(\d{1,2})\b/);
      if (numberMatch) {
        const dayOfMonth = parseInt(numberMatch[1], 10);
        if (dayOfMonth >= 1 && dayOfMonth <= 31) {
          return parseDateNumber(dayOfMonth, cleaned, now, timeZone);
        }
      }
    }
  }
  return null;
}
__name(extractRequestedDate, "extractRequestedDate");
function parseDateNumber(dayOfMonth, text, now, timeZone) {
  const parts = new Intl.DateTimeFormat("en-US", {
    timeZone,
    year: "numeric",
    month: "numeric",
    day: "numeric"
  }).formatToParts(now);
  const year = parseInt(parts.find((p) => p.type === "year")?.value || "0", 10);
  const month = parseInt(parts.find((p) => p.type === "month")?.value || "0", 10);
  const monthNames = [
    "january",
    "february",
    "march",
    "april",
    "may",
    "june",
    "july",
    "august",
    "september",
    "october",
    "november",
    "december"
  ];
  let targetMonth = month;
  for (let i = 0; i < monthNames.length; i++) {
    if (text.includes(monthNames[i])) {
      targetMonth = i + 1;
      break;
    }
  }
  let candidate = new Date(Date.UTC(year, targetMonth - 1, dayOfMonth, 12, 0, 0));
  if (candidate.getTime() < now.getTime()) {
    candidate = new Date(Date.UTC(year, targetMonth, dayOfMonth, 12, 0, 0));
  }
  return candidate;
}
__name(parseDateNumber, "parseDateNumber");
function parseRelativeDate(text, now, timeZone) {
  const cleaned = text.toLowerCase().trim();
  const currentDayOfWeek = now.getUTCDay();
  const dayNames = {
    "sunday": 0,
    "monday": 1,
    "tuesday": 2,
    "wednesday": 3,
    "thursday": 4,
    "friday": 5,
    "saturday": 6
  };
  if (cleaned.includes("tomorrow")) {
    const tomorrow = new Date(now);
    tomorrow.setUTCDate(tomorrow.getUTCDate() + 1);
    tomorrow.setUTCHours(12, 0, 0, 0);
    return tomorrow;
  }
  if (cleaned.includes("today")) {
    const today = new Date(now);
    today.setUTCHours(12, 0, 0, 0);
    return today;
  }
  for (const [dayName, targetDay] of Object.entries(dayNames)) {
    if (!cleaned.includes(dayName)) continue;
    const hasNext = cleaned.includes("next");
    const hasThis = cleaned.includes("this");
    let daysToAdd = 0;
    if (hasNext) {
      daysToAdd = (targetDay - currentDayOfWeek + 7) % 7;
      if (daysToAdd === 0) daysToAdd = 7;
      if (daysToAdd < 7) daysToAdd += 7;
    } else if (hasThis) {
      daysToAdd = (targetDay - currentDayOfWeek + 7) % 7;
    } else {
      daysToAdd = (targetDay - currentDayOfWeek + 7) % 7;
    }
    const targetDate = new Date(now);
    targetDate.setUTCDate(targetDate.getUTCDate() + daysToAdd);
    targetDate.setUTCHours(12, 0, 0, 0);
    return targetDate;
  }
  return null;
}
__name(parseRelativeDate, "parseRelativeDate");

// src/resend.ts
async function sendChatbotBookingEmail(env, data) {
  if (!env.RESEND_API_KEY) {
    console.error("[RESEND] No API key configured, skipping email notification");
    return;
  }
  const emailBody = {
    from: "Sparkle Auto Detailing <bookings@sparkleautodetailingllc.com>",
    to: ["nyeamanbusiness@gmail.com"],
    subject: `New Booking: ${data.slotLabel}`,
    html: `
      <h2>New Booking from Messenger Bot</h2>
      
      <h3>Appointment Details:</h3>
      <ul>
        <li><strong>Time:</strong> ${data.slotLabel}</li>
        <li><strong>Address:</strong> ${data.address}</li>
        <li><strong>Phone:</strong> ${data.phone}</li>
      </ul>
      
      <h3>Technical Details:</h3>
      <ul>
        <li><strong>Google Calendar Event ID:</strong> ${data.eventId}</li>
        <li><strong>Customer PSID:</strong> ${data.psid}</li>
      </ul>
      
      <p><em>This booking was made through the Facebook Messenger chatbot.</em></p>
    `,
    text: `
New Booking from Messenger Bot

Appointment Details:
- Time: ${data.slotLabel}
- Address: ${data.address}
- Phone: ${data.phone}

Technical Details:
- Google Calendar Event ID: ${data.eventId}
- Customer PSID: ${data.psid}

This booking was made through the Facebook Messenger chatbot.
    `.trim()
  };
  try {
    console.log("[RESEND] Sending booking notification email...");
    const response = await fetch("https://api.resend.com/emails", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${env.RESEND_API_KEY}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(emailBody)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Resend API error ${response.status}: ${errorText}`);
    }
    const result = await response.json();
    console.log("[RESEND] \u2705 Email sent successfully:", result);
  } catch (error) {
    console.error("[RESEND] \u274C Failed to send email:", error);
  }
}
__name(sendChatbotBookingEmail, "sendChatbotBookingEmail");

// src/flow.ts
function pick(arr, seed) {
  if (seed) {
    let hash = 0;
    for (let i = 0; i < seed.length; i++) {
      hash = (hash << 5) - hash + seed.charCodeAt(i);
      hash = hash & hash;
    }
    return arr[Math.abs(hash) % arr.length];
  }
  return arr[Math.floor(Math.random() * arr.length)];
}
__name(pick, "pick");
function getSlotDate(slot, timezone = "America/Denver") {
  const date = new Date(slot.startISO);
  const month = new Intl.DateTimeFormat("en-US", { month: "long", timeZone: timezone }).format(date);
  const day = new Intl.DateTimeFormat("en-US", { day: "numeric", timeZone: timezone }).format(date);
  const ordinal = getOrdinalSuffix(parseInt(day));
  return `${month} ${day}${ordinal}`;
}
__name(getSlotDate, "getSlotDate");
function hardClose(env, slots, seed) {
  if (slots.length < 1) {
    return "What day/time works best for you?";
  }
  if (slots.length >= 2) {
    const date1 = getSlotDate(slots[0]);
    const date2 = getSlotDate(slots[1]);
    const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    if (date1 === date2 && time1 !== time2) {
      const dayName = slots[0].label.match(/^(\w+day)/i)?.[1] || "";
      const variants2 = [
        `Hey! \u{1F44B} I can get you in for a ${env.SERVICE_NAME} \u2014 it's ${env.SERVICE_PRICE}. I've got ${dayName} at ${time1} or ${time2}. Does one of those work, or tell me what date works best for you?`,
        `Perfect timing \u2014 ${env.SERVICE_NAME} is ${env.SERVICE_PRICE}. I can do ${dayName} at ${time1} or ${time2}. Which works better, or what day would you prefer?`,
        `Awesome. ${env.SERVICE_PRICE} for the ${env.SERVICE_NAME}. I've got ${dayName} at ${time1} or ${time2}. Want one of those, or tell me what date works for you?`,
        `Hey! ${env.SERVICE_NAME} is ${env.SERVICE_PRICE}. I can do ${dayName} at ${time1} or ${time2}. Does one work, or what day is better for you?`
      ];
      return pick(variants2, seed);
    }
  }
  const slot = slots[0];
  const variants = [
    `Hey! \u{1F44B} I can get you in for a ${env.SERVICE_NAME} \u2014 it's ${env.SERVICE_PRICE}. I've got ${slot.label} available. Does that work, or tell me what date works best for you?`,
    `Perfect timing \u2014 ${env.SERVICE_NAME} is ${env.SERVICE_PRICE}. I can do ${slot.label}. Does that work, or what day would you prefer?`,
    `Awesome. ${env.SERVICE_PRICE} for the ${env.SERVICE_NAME}. I've got ${slot.label}. Want me to lock it in, or tell me what date works for you?`,
    `Hey! ${env.SERVICE_NAME} is ${env.SERVICE_PRICE}. I can do ${slot.label}. Does that work, or what day is better for you?`
  ];
  return pick(variants, seed);
}
__name(hardClose, "hardClose");
function reClose(slots, seed, includeDate = false) {
  if (slots.length < 1) {
    return "What day/time works best for you?";
  }
  if (slots.length >= 2) {
    const date1 = getSlotDate(slots[0]);
    const date2 = getSlotDate(slots[1]);
    const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    if (date1 === date2 && time1 !== time2) {
      const dayName = slots[0].label.match(/^(\w+day)/i)?.[1] || "";
      const dateStr2 = includeDate ? ` (${date1})` : "";
      const variants2 = [
        `I've got ${dayName}${dateStr2} at ${time1} or ${time2}. Does one work, or tell me what date works best for you?`,
        `I can do ${dayName}${dateStr2} at ${time1} or ${time2}. Which is better, or what day would you prefer?`,
        `${dayName}${dateStr2} at ${time1} or ${time2} is open. Want one of those, or what day works for you?`,
        `I've got ${dayName}${dateStr2} at ${time1} or ${time2}. Does one work for you, or what day would be better?`
      ];
      return pick(variants2, seed);
    }
  }
  const slot = slots[0];
  const dateStr = includeDate ? ` (${getSlotDate(slot)})` : "";
  const variants = [
    `I've got ${slot.label}${dateStr} available. Does that work, or tell me what date works best for you?`,
    `I can do ${slot.label}${dateStr}. Does that work, or what day would you prefer?`,
    `${slot.label}${dateStr} is open. Want me to lock it in, or what day is better?`,
    `I've got ${slot.label}${dateStr}. Does that work for you, or what day would be better?`
  ];
  return pick(variants, seed);
}
__name(reClose, "reClose");
function dayClose(dayName, slots, seed) {
  if (slots.length < 1) {
    return `I don't have ${dayName} available. What other day works for you?`;
  }
  const actualDate = getSlotDate(slots[0]);
  if (slots.length >= 2) {
    const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    if (time1 !== time2) {
      const variants2 = [
        `Yep \u2014 I can do ${dayName}, ${actualDate} at ${time1} or ${time2}. Does one work, or what day would be better?`,
        `Yes! ${dayName}, ${actualDate} works. I've got ${time1} or ${time2}. Which is better, or tell me what date you prefer?`,
        `For sure \u2014 ${dayName}, ${actualDate} at ${time1} or ${time2}. Want one of those, or what day works for you?`,
        `Yep! ${dayName}, ${actualDate}. I can do ${time1} or ${time2}. Does one work, or what day is better?`
      ];
      return pick(variants2, seed);
    }
  }
  const slot = slots[0];
  const variants = [
    `Yep \u2014 I can do ${dayName}, ${actualDate}. ${slot.label} is open. Does that work, or what day would be better?`,
    `Yes! ${dayName}, ${actualDate} works. I've got ${slot.label}. Want me to lock it in, or tell me what date you prefer?`,
    `For sure \u2014 ${dayName}, ${actualDate} is available. ${slot.label}. Does that work for you?`,
    `Yep! ${dayName}, ${actualDate}. I can do ${slot.label}. Want it, or what day is better?`
  ];
  return pick(variants, seed);
}
__name(dayClose, "dayClose");
function dateClose(dayName, monthName, dateNum, slots, seed) {
  const ordinal = getOrdinalSuffix(dateNum);
  if (slots.length < 1) {
    return `That date is fully booked. What other day works for you?`;
  }
  if (slots.length >= 2) {
    const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
    if (time1 !== time2) {
      const variants2 = [
        `Yep \u2014 ${dayName}, ${monthName} the ${dateNum}${ordinal} at ${time1} or ${time2}. Does one work, or what day would be better?`,
        `Yes! ${dayName}, ${monthName} the ${dateNum}${ordinal}. I've got ${time1} or ${time2}. Which is better, or tell me what date you prefer?`,
        `For sure \u2014 ${dayName}, ${monthName} the ${dateNum}${ordinal} at ${time1} or ${time2}. Want one of those?`,
        `${dayName}, ${monthName} the ${dateNum}${ordinal} works. ${time1} or ${time2}. Does one work, or what day is better?`
      ];
      return pick(variants2, seed);
    }
  }
  const slot = slots[0];
  const variants = [
    `Yep \u2014 ${dayName}, ${monthName} the ${dateNum}${ordinal} works. ${slot.label} is open. Does that work, or what day would be better?`,
    `Yes! ${dayName}, ${monthName} the ${dateNum}${ordinal}. I've got ${slot.label}. Want me to lock it in, or tell me what date you prefer?`,
    `For sure \u2014 ${dayName}, ${monthName} the ${dateNum}${ordinal}. ${slot.label}. Does that work for you?`
  ];
  return pick(variants, seed);
}
__name(dateClose, "dateClose");
function attachmentClose(slots, seed) {
  if (slots.length < 1) {
    return "Got it \u2014 we can handle that. What day/time works best for you?";
  }
  const slot = slots[0];
  const variants = [
    `Got it \u2014 we can handle that. I've got ${slot.label} available. Does that work, or what day would be better?`,
    `Perfect \u2014 we do that. ${slot.label} is open. Want me to lock it in, or tell me what date you prefer?`,
    `Yep, we handle that. I can do ${slot.label}. Does that work for you?`
  ];
  return pick(variants, seed);
}
__name(attachmentClose, "attachmentClose");
function stopResponse() {
  return "No problem \u2014 I'll stop messaging you.";
}
__name(stopResponse, "stopResponse");
function humanResponse() {
  return "Sure \u2014 what's the best number to reach you?";
}
__name(humanResponse, "humanResponse");
function claimedAskAddress(slotLabel, seed) {
  const variants = [
    `Perfect \u2014 I can hold ${slotLabel} for you. What's the address for the service?`,
    `Got it \u2014 ${slotLabel} is yours. Where should we come to?`,
    `Awesome \u2014 holding ${slotLabel} for you. What's the service address?`,
    `Great! ${slotLabel} is reserved. What address?`
  ];
  return pick(variants, seed);
}
__name(claimedAskAddress, "claimedAskAddress");
function collectedAddressAskPhone(seed) {
  const variants = [
    `Perfect \u2014 and what's the best phone number to reach you?`,
    `Got it \u2014 what's your phone number?`,
    `Great \u2014 phone number?`,
    `Awesome \u2014 best number to call you?`
  ];
  return pick(variants, seed);
}
__name(collectedAddressAskPhone, "collectedAddressAskPhone");
function finalizedBooking(slotLabel, seed) {
  const variants = [
    `Perfect \u2014 you're all set \u2705 We'll see you ${slotLabel}!`,
    `Done \u2705 \u2014 booked for ${slotLabel}. See you then!`,
    `You're booked \u2705 \u2014 ${slotLabel}. Looking forward to it!`,
    `All set \u2705 \u2014 ${slotLabel} is confirmed. See you soon!`
  ];
  return pick(variants, seed);
}
__name(finalizedBooking, "finalizedBooking");
function pendingExpired(slots, seed) {
  if (slots.length < 1) {
    return "Sorry \u2014 that time got away. What day works best for you?";
  }
  const slot = slots[0];
  const variants = [
    `Sorry \u2014 that slot got taken. I've got ${slot.label} available now. Does that work, or what day is better?`,
    `Ah \u2014 someone grabbed that time. I can do ${slot.label}. Want me to lock it in, or tell me what date you prefer?`,
    `That slot filled up \u2014 but I have ${slot.label}. Does that work for you?`
  ];
  return pick(variants, seed);
}
__name(pendingExpired, "pendingExpired");
function getOrdinalSuffix(day) {
  if (day > 3 && day < 21) return "th";
  switch (day % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
    default:
      return "th";
  }
}
__name(getOrdinalSuffix, "getOrdinalSuffix");
function detectStop(text) {
  const normalized = text.toLowerCase().trim();
  const stopKeywords = [
    "stop",
    "unsubscribe",
    "quit",
    "don't message",
    "dont message",
    "cancel",
    "nevermind",
    "never mind",
    "not interested"
  ];
  return stopKeywords.some((keyword) => normalized.includes(keyword));
}
__name(detectStop, "detectStop");
function detectHuman(text) {
  const normalized = text.toLowerCase().trim();
  const humanKeywords = ["human", "agent", "call me", "speak to someone", "talk to someone"];
  return humanKeywords.some((keyword) => normalized.includes(keyword));
}
__name(detectHuman, "detectHuman");
function detectGratitude(text) {
  const normalized = text.toLowerCase().trim();
  const gratitudeKeywords = [
    "thanks",
    "thank you",
    "appreciate",
    "perfect",
    "awesome",
    "great",
    "sounds good",
    "ok thanks",
    "okay thanks",
    "cool thanks",
    "got it thanks"
  ];
  return gratitudeKeywords.some((keyword) => normalized.includes(keyword));
}
__name(detectGratitude, "detectGratitude");
function gratitudeResponse(seed) {
  const variants = [
    "You're all set! \u{1F64C} Hit me up if you need anything else.",
    "Perfect! See you then. Let me know if anything comes up.",
    "Awesome! You're good to go. Reach out if you need to adjust anything.",
    "You got it! See you soon. \u{1F44D}",
    "All set! Let me know if you need anything before then.",
    "Perfect! Looking forward to it. Hit me up if plans change."
  ];
  return pick(variants, seed);
}
__name(gratitudeResponse, "gratitudeResponse");
function detectChangeRequest(text) {
  const normalized = text.toLowerCase().trim();
  const changeKeywords = [
    "change",
    "reschedule",
    "different day",
    "different time",
    "move it",
    "switch",
    "adjust",
    "modify",
    "update"
  ];
  return changeKeywords.some((keyword) => normalized.includes(keyword));
}
__name(detectChangeRequest, "detectChangeRequest");
function detectRegenerateSlots(text) {
  const normalized = text.toLowerCase().trim();
  if (normalized.endsWith("?")) {
    return false;
  }
  if (normalized.split(/\s+/).length <= 2) {
    return false;
  }
  const regenerateKeywords = [
    "different time",
    "another time",
    "other options",
    "something else",
    "neither",
    "not those",
    "different day",
    "show me more",
    "what else",
    "any other",
    "anything else",
    "give me other",
    "show other"
  ];
  return regenerateKeywords.some((keyword) => normalized.includes(keyword));
}
__name(detectRegenerateSlots, "detectRegenerateSlots");
function detectQuestionType(text) {
  const normalized = text.toLowerCase().trim();
  if (normalized.includes("what services") || normalized.includes("what service") || normalized.includes("tell me about") || normalized.includes("what do you do") || normalized.includes("what can you do") || normalized.includes("services do you") || normalized.includes("help") || normalized.includes("info") || normalized.includes("information") || normalized.includes("service") && normalized.includes("?")) {
    return "services";
  }
  if (normalized.includes("dog") || normalized.includes("pet") || normalized.includes("hair") || normalized.includes("fur")) {
    return "dog_hair";
  }
  if (normalized.includes("include") || normalized.includes("what do you") || normalized.includes("what does") || normalized.includes("what is included") || normalized.includes("what comes with")) {
    return "included";
  }
  if (normalized.includes("price") || normalized.includes("cost") || normalized.includes("how much") || normalized.includes("charge") || normalized.includes("fee")) {
    return "price";
  }
  if (normalized.includes("zip") || normalized.includes("location") || normalized.includes("where") || normalized.includes("area") || normalized.includes("service area") || normalized.includes("come to")) {
    return "zip";
  }
  if (normalized.includes("long") || normalized.includes("duration") || normalized.includes("how many hours") || normalized.includes("take") && normalized.includes("time")) {
    return "duration";
  }
  if (normalized.includes("reschedule") || normalized.includes("cancel") || normalized.includes("change")) {
    return "reschedule";
  }
  if (normalized.endsWith("?") && (normalized.includes("day") || normalized.includes("time") || normalized.includes("sunday") || normalized.includes("monday") || normalized.includes("tuesday") || normalized.includes("wednesday") || normalized.includes("thursday") || normalized.includes("friday") || normalized.includes("saturday") || normalized.includes("other") || normalized.includes("available") || normalized.includes("when") || normalized.includes("january") || normalized.includes("february") || normalized.includes("march") || normalized.includes("april") || normalized.includes("may") || normalized.includes("june") || normalized.includes("july") || normalized.includes("august") || normalized.includes("september") || normalized.includes("october") || normalized.includes("november") || normalized.includes("december") || /\d{1,2}(st|nd|rd|th)?/.test(normalized))) {
    return "availability";
  }
  if (normalized.endsWith("?")) {
    return "generic";
  }
  return "unknown";
}
__name(detectQuestionType, "detectQuestionType");
function answerQuestion(env, qType, addons, seed) {
  switch (qType) {
    case "services": {
      return `Interior \u2014 thorough vacuuming, door and seat jams cleaned, plastics and rubber treated, floor mats cleaned, and windows streak-free.

Exterior \u2014 Foam cannon pre-wash, hand wash, towel dry, wheels and tires cleaned and dressed.`;
    }
    case "dog_hair": {
      const dogHairAddon = addons.find((a) => a.addon_key === "dog_hair");
      if (dogHairAddon) {
        const price = `$${(dogHairAddon.price_cents / 100).toFixed(0)}`;
        const variants = [
          `Totally \u2014 that's exactly what we do. For dog hair, it's an additional ${price}.`,
          `Yep, we handle that all the time. Dog hair removal is ${price} extra.`,
          `For sure. Dog hair is ${price} extra.`
        ];
        return pick(variants, seed);
      }
      return `Yep, we handle dog hair removal. It's an additional charge depending on severity.`;
    }
    case "included": {
      return `Interior \u2014 thorough vacuuming, door and seat jams cleaned, plastics and rubber treated, floor mats cleaned, and windows streak-free.

Exterior \u2014 Foam cannon pre-wash, hand wash, towel dry, wheels and tires cleaned and dressed.`;
    }
    case "price": {
      const variants = [
        `The ${env.SERVICE_NAME} is ${env.SERVICE_PRICE}.`,
        `${env.SERVICE_PRICE} for the ${env.SERVICE_NAME}.`,
        `It's ${env.SERVICE_PRICE} for the full ${env.SERVICE_NAME}.`
      ];
      return pick(variants, seed);
    }
    case "zip": {
      const variants = [
        `We're mobile \u2014 we come to you! We serve Northern Utah. What's your ZIP code?`,
        `We come to your location. We cover Northern Utah. What ZIP are you in?`,
        `Mobile service \u2014 we come to you in Northern Utah. What's your ZIP?`
      ];
      return pick(variants, seed);
    }
    case "duration": {
      const variants = [
        `The service typically takes 2-3 hours.`,
        `Usually 2-3 hours depending on the vehicle.`,
        `About 2-3 hours for the full detail.`
      ];
      return pick(variants, seed);
    }
    case "reschedule": {
      const variants = [
        `No problem, we can adjust your appointment.`,
        `Sure thing \u2014 we can move it.`,
        `Totally \u2014 let's reschedule.`
      ];
      return pick(variants, seed);
    }
    case "availability": {
      const variants = [
        `Let me check what else is available.`,
        `Sure \u2014 let me see what I've got.`,
        `Yep, let me pull up the schedule.`
      ];
      return pick(variants, seed);
    }
    case "generic": {
      const variants = [
        `Got it.`,
        `Yep.`,
        `For sure.`,
        `Totally.`
      ];
      return pick(variants, seed);
    }
    default:
      return "Got it.";
  }
}
__name(answerQuestion, "answerQuestion");
function tryMatchSlot(text, slots) {
  if (!slots || slots.length === 0) {
    return { matched: false };
  }
  const normalized = text.toLowerCase().trim();
  const confirmWords = ["yes", "yeah", "yep", "sure", "ok", "okay", "sounds good", "that works", "perfect", "great"];
  const isConfirmWord = confirmWords.some((word) => normalized === word || normalized.includes(word));
  if (isConfirmWord) {
    if (slots.length === 1) {
      return { matched: true, slot: slots[0] };
    } else if (slots.length >= 2) {
      const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
      const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || "";
      if (time1 === time2) {
        return { matched: true, slot: slots[0] };
      } else {
        return { matched: false, requiresChoice: true };
      }
    }
  }
  if (normalized === "1" && slots.length >= 1) {
    return { matched: true, slot: slots[0] };
  }
  if (normalized === "2" && slots.length >= 2) {
    return { matched: true, slot: slots[1] };
  }
  const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  for (const dayName of dayNames) {
    if (normalized.includes(dayName)) {
      for (const slot of slots) {
        if (slot.label.toLowerCase().includes(dayName)) {
          return { matched: true, slot };
        }
      }
    }
  }
  for (const slot of slots) {
    if (normalized === slot.label.toLowerCase()) {
      return { matched: true, slot };
    }
  }
  let userTime = normalized.replace(/\s/g, "");
  if (/^\d{1,2}:\d{2}$/.test(userTime)) {
    const [hourStr, minutes] = userTime.split(":");
    const hour = parseInt(hourStr, 10);
    if (hour >= 1 && hour <= 12) {
      for (const slot of slots) {
        const slotLower = slot.label.toLowerCase();
        const timeMatch = slotLower.match(/(\d{1,2}):(\d{2})\s*(am|pm)/i);
        if (timeMatch) {
          const slotHour = parseInt(timeMatch[1], 10);
          const slotMinutes = timeMatch[2];
          if (slotHour === hour && slotMinutes === minutes) {
            return { matched: true, slot };
          }
        }
      }
    }
  }
  if (/^\d{1,2}$/.test(userTime)) {
    const hour = parseInt(userTime, 10);
    if (hour >= 1 && hour <= 12) {
      for (const slot of slots) {
        const slotLower = slot.label.toLowerCase();
        const timeMatch = slotLower.match(/(\d{1,2}):(\d{2})\s*(am|pm)/i);
        if (timeMatch) {
          const slotHour = parseInt(timeMatch[1], 10);
          const slotMinutes = timeMatch[2];
          if (slotHour === hour && slotMinutes === "00") {
            return { matched: true, slot };
          }
        }
      }
    }
  }
  if (/^\d{1,2}(am|pm)$/i.test(userTime)) {
    userTime = userTime.replace(/^(\d{1,2})(am|pm)$/i, "$1:00$2");
  }
  if (userTime === "noon") {
    userTime = "12:00pm";
  }
  if (userTime === "midnight") {
    userTime = "12:00am";
  }
  for (const slot of slots) {
    const slotLower = slot.label.toLowerCase();
    const timeMatch = slotLower.match(/(\d{1,2}:\d{2}\s*(?:am|pm))/i);
    if (timeMatch) {
      const slotTime = timeMatch[1].replace(/\s/g, "").toLowerCase();
      if (userTime === slotTime) {
        return { matched: true, slot };
      }
    }
  }
  for (const slot of slots) {
    const slotLower = slot.label.toLowerCase();
    const dayMatch = slotLower.match(/^(\w+day)/);
    const timeMatch = slotLower.match(/(\d{1,2}:\d{2}\s*(?:am|pm))/i);
    if (dayMatch && timeMatch) {
      const day = dayMatch[1];
      const time = timeMatch[1].replace(/\s/g, "");
      const normalizedNoSpaces = normalized.replace(/\s/g, "");
      if (normalized.includes(day) && normalizedNoSpaces.includes(time.toLowerCase())) {
        return { matched: true, slot };
      }
    }
  }
  return { matched: false };
}
__name(tryMatchSlot, "tryMatchSlot");

// src/context.ts
function extractDayName(slotLabel) {
  const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
  const normalized = slotLabel.toLowerCase();
  for (const day of dayNames) {
    if (normalized.includes(day)) {
      return day;
    }
  }
  return "";
}
__name(extractDayName, "extractDayName");
function getDaysFromSlots(slots) {
  return slots.map((s) => extractDayName(s.label)).filter((d) => d !== "");
}
__name(getDaysFromSlots, "getDaysFromSlots");
function initializeContext(context) {
  return {
    ...context,
    offeredDays: context.offeredDays || [],
    attemptCount: context.attemptCount || 0,
    lastIntent: context.lastIntent || "unknown"
  };
}
__name(initializeContext, "initializeContext");
function trackOfferedSlots(context, slots, isSuccessfulMatch = false) {
  const newDays = getDaysFromSlots(slots);
  const existingDays = context.offeredDays || [];
  const allDays = [.../* @__PURE__ */ new Set([...existingDays, ...newDays])];
  const newAttemptCount = isSuccessfulMatch ? 0 : (context.attemptCount || 0) + 1;
  return {
    ...context,
    slots,
    offeredDays: allDays,
    attemptCount: newAttemptCount
  };
}
__name(trackOfferedSlots, "trackOfferedSlots");
function trackRequestedDay(context, day) {
  return {
    ...context,
    requestedDay: day
  };
}
__name(trackRequestedDay, "trackRequestedDay");
function trackIntent(context, intent) {
  return {
    ...context,
    lastIntent: intent
  };
}
__name(trackIntent, "trackIntent");
function shouldTriggerGracefulDegradation(context) {
  return (context.attemptCount || 0) >= 3;
}
__name(shouldTriggerGracefulDegradation, "shouldTriggerGracefulDegradation");
function shouldAskOpenEnded(context) {
  return (context.attemptCount || 0) >= 2;
}
__name(shouldAskOpenEnded, "shouldAskOpenEnded");
function resetAttemptCount(context) {
  return {
    ...context,
    attemptCount: 0
  };
}
__name(resetAttemptCount, "resetAttemptCount");
function getExcludedDays(context) {
  return context.offeredDays || [];
}
__name(getExcludedDays, "getExcludedDays");

// src/index.ts
var index_default = {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    if (url.pathname === "/health" && request.method === "GET") {
      return new Response(JSON.stringify({ status: "ok" }), {
        status: 200,
        headers: { "Content-Type": "application/json" }
      });
    }
    if (url.pathname === "/webhook") {
      if (request.method === "GET") {
        const mode = url.searchParams.get("hub.mode");
        const token = url.searchParams.get("hub.verify_token");
        const challenge = url.searchParams.get("hub.challenge");
        if (mode === "subscribe" && token === env.META_VERIFY_TOKEN) {
          return new Response(challenge, { status: 200 });
        }
        return new Response("Forbidden", { status: 403 });
      }
      if (request.method === "POST") {
        try {
          const rawBody = await request.arrayBuffer();
          await verifyMetaSignatureOrThrow(request, env.META_APP_SECRET, rawBody);
          const payload = JSON.parse(new TextDecoder().decode(rawBody));
          const response = new Response("OK", { status: 200 });
          ctx.waitUntil(processPayload(payload, env));
          return response;
        } catch (error) {
          console.error("Webhook error:", error);
          return new Response("Unauthorized", { status: 401 });
        }
      }
    }
    return new Response("Not Found", { status: 404 });
  }
};
async function processPayload(payload, env) {
  const repo = new SupabaseRepo(env.SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY);
  const gcal = new GoogleCalendar(env);
  let addons = [];
  try {
    addons = await repo.getActiveAddons();
    console.log(`[ADDONS] Loaded ${addons.length} active addons`);
  } catch (addonError) {
    console.error("[ADDONS] Failed to load addons:", addonError);
  }
  for (const entry of payload.entry ?? []) {
    for (const ev of entry.messaging ?? []) {
      try {
        if (ev.delivery || ev.read || ev.message?.is_echo) continue;
        if (!ev.sender?.id) continue;
        const psid = ev.sender.id;
        const lead = await repo.upsertLeadByPsid(psid);
        const text = ev.message?.text ?? null;
        let fallbackKey = `fallback:${psid}:${ev.timestamp}`;
        if (text) {
          fallbackKey += `:${text}`;
        } else if (ev.message?.attachments) {
          const attachments = ev.message.attachments.map((att) => ({
            type: att.type,
            // Use stable IDs if available (stickers, reusable attachments)
            id: att.payload?.attachment_id ?? att.payload?.sticker_id ?? "",
            url: att.payload?.url ?? att.payload?.reusable_url ?? "",
            title: att.payload?.title ?? ""
          }));
          const attachmentHash = JSON.stringify(attachments);
          fallbackKey += `:att:${attachmentHash.substring(0, 50)}`;
        } else {
          fallbackKey += ":no_content";
        }
        const dedupeKey = ev.message?.mid ?? fallbackKey;
        const alreadyProcessed = await repo.tryInsertDedupe(dedupeKey, lead.id);
        if (alreadyProcessed) continue;
        await repo.insertInboundMessage(lead.id, text, ev);
        try {
          await repo.saveConversationHistory(lead.id, "user", text);
        } catch (historyError) {
          console.error("[History] Failed to save:", historyError);
        }
        try {
          const existingHistory = await repo.loadConversationHistory(lead.id, 1);
          if (existingHistory.length === 0) {
            await repo.trackEvent(lead.id, "conversation_started", { psid });
          }
        } catch (analyticsError) {
          console.error("[Analytics] Failed to track conversation start:", analyticsError);
        }
        if (lead.bot_enabled === false) {
          console.log("[BOT DISABLED] Ignoring message - bot_enabled is false for lead:", lead.id);
          continue;
        }
        if (!ev.message?.text) {
          let state2 = await repo.getConvoState(lead.id);
          if (!state2) state2 = await repo.upsertConvoState(lead.id, "start", {});
          if (!Array.isArray(state2.context.slots) || state2.context.slots.length < 2) {
            const slots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
              daysPrimary: 7,
              daysFallback: 14
            });
            state2.context.slots = slots;
            state2.step = "closing";
            await repo.upsertConvoState(lead.id, state2.step, state2.context);
          }
          const reply2 = attachmentClose(state2.context.slots);
          await repo.insertOutboundMessage(lead.id, reply2, { psid, kind: "attachment_close" });
          await sendTextMessage(psid, reply2, env.FB_PAGE_ACCESS_TOKEN);
          continue;
        }
        let state = await repo.getConvoState(lead.id);
        if (!state) state = await repo.upsertConvoState(lead.id, "start", {});
        state.context = initializeContext(state.context);
        const greetings = ["hi", "hello", "hey", "start", "restart", "reset"];
        if (greetings.includes(text.toLowerCase().trim())) {
          console.log("[RESET] Conversation reset for greeting:", text);
          await repo.releaseBookingClaim(lead.id);
          await repo.setLeadStatus(lead.id, "active");
          console.log("[RESET] Released any existing booking");
          state.step = "start";
          state.context = initializeContext({});
        }
        let reply = "";
        if (state.step === "start") {
          const qType = detectQuestionType(text);
          if (qType === "services") {
            console.log("[SERVICE INQUIRY] User asking about services");
            state.context = trackIntent(state.context, "service_inquiry");
            const addons2 = await repo.getActiveAddons();
            const answer = answerQuestion(env, qType, addons2, psid);
            reply = answer;
            state.step = "closing";
            const slots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
              daysPrimary: 7,
              daysFallback: 14
            });
            if (slots && slots.length >= 2) {
              state.context = trackOfferedSlots(state.context, slots);
            }
          } else if (detectGratitude(text)) {
            console.log("[GRATITUDE] User expressing thanks, responding naturally");
            state.context = trackIntent(state.context, "gratitude");
            reply = gratitudeResponse(psid);
          } else {
            console.log("[START] Generating initial slots");
            const slots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
              daysPrimary: 7,
              daysFallback: 14
            });
            console.log("[START] Generated slots:", slots?.map((s) => s.label));
            if (!slots || slots.length < 1) {
              reply = "What day/time works for you?";
            } else {
              state.context = trackOfferedSlots(state.context, slots.length >= 2 ? [slots[0], slots[1]] : [slots[0]]);
              state.step = "closing";
              reply = hardClose(env, slots.length >= 2 ? [slots[0], slots[1]] : [slots[0]], psid);
            }
          }
        } else if (state.step === "closing") {
          const qType = detectQuestionType(text);
          if (qType !== "unknown" && qType !== "availability" && !detectStop(text) && !detectHuman(text) && !detectRegenerateSlots(text)) {
            console.log("[FAQ] Detected question type:", qType);
            state.context = trackIntent(state.context, `faq_${qType}`);
            const slots = state.context.slots ?? [];
            let slotLabels;
            if (slots.length >= 2) {
              slotLabels = [slots[0].label, slots[1].label];
            } else if (slots.length === 1) {
              slotLabels = [slots[0].label, slots[0].label];
            } else {
              const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                daysPrimary: 7,
                daysFallback: 14
              });
              state.context.slots = newSlots;
              slotLabels = newSlots.length >= 2 ? [newSlots[0].label, newSlots[1].label] : ["available time", "available time"];
            }
            try {
              const faqAnswer = await deepSeekAnswer({
                env,
                question: text,
                serviceName: env.SERVICE_NAME,
                servicePrice: env.SERVICE_PRICE,
                addons,
                slotLabels
                // Always exactly 2
              });
              reply = faqAnswer;
              console.log("[FAQ] DeepSeek answer provided");
            } catch (e) {
              console.error("[FAQ] DeepSeek failed:", e);
              const answer = answerQuestion(env, qType, addons, psid);
              reply = `${answer} ${reClose(state.context.slots ?? [], psid)}`;
            }
          } else if (shouldTriggerGracefulDegradation(state.context)) {
            console.log("[GRACEFUL] Triggering human handoff after 3 attempts");
            await repo.setLeadStatus(lead.id, "needs_followup");
            try {
              await repo.trackEvent(lead.id, "human_handoff_requested", {
                reason: "repeated_failure",
                attemptCount: state.context.attemptCount
              });
            } catch (analyticsError) {
              console.error("[Analytics] Failed to track handoff:", analyticsError);
            }
            state.context = resetAttemptCount(state.context);
            reply = "I'm having trouble finding the perfect time for you. Let me have someone call you to schedule. What's the best number to reach you?";
          } else if (detectStop(text)) {
            state.context = trackIntent(state.context, "stop");
            await repo.setLeadStatus(lead.id, "dead");
            reply = stopResponse();
          } else if (detectHuman(text)) {
            state.context = trackIntent(state.context, "human_request");
            await repo.setLeadStatus(lead.id, "needs_followup");
            reply = humanResponse();
          } else if (detectRegenerateSlots(text)) {
            state.context = trackIntent(state.context, "regenerate_slots");
            const excludeDays = getExcludedDays(state.context);
            const newSlots = await gcal.generateTwoSlotsFixedWindows(14, excludeDays, 2);
            if (newSlots.length >= 2) {
              state.context = trackOfferedSlots(state.context, newSlots);
              reply = `Sure! ${reClose(newSlots, psid)}`;
            } else {
              reply = "What day works best for you?";
            }
          } else {
            const slots = state.context.slots ?? [];
            const requestedDate = extractRequestedDate(text, /* @__PURE__ */ new Date(), env.GOOGLE_TIMEZONE);
            console.log(`[Date/Day Detection] User text: "${text}"`);
            console.log(`[Date/Day Detection] Requested date from parser:`, requestedDate ? requestedDate.toISOString() : "NULL");
            if (requestedDate) {
              console.log(`[Date Request] User wants specific date: ${requestedDate.toISOString()}`);
              state.context = trackIntent(state.context, "date_request");
              const dateSlots = await gcal.generateTwoSlots(
                env.GOOGLE_TIMEZONE,
                { daysPrimary: 7, daysFallback: 14 },
                requestedDate
                // Force this date
              );
              console.log(`[Date Request] Found ${dateSlots.length} slots for requested date`);
              if (dateSlots.length >= 2) {
                state.context = trackOfferedSlots(state.context, dateSlots.slice(0, 2), true);
                const dayName = new Intl.DateTimeFormat("en-US", {
                  weekday: "long",
                  timeZone: env.GOOGLE_TIMEZONE
                }).format(requestedDate);
                const monthName = new Intl.DateTimeFormat("en-US", {
                  month: "long",
                  timeZone: env.GOOGLE_TIMEZONE
                }).format(requestedDate);
                reply = dateClose(dayName, monthName, requestedDate.getUTCDate(), state.context.slots, psid);
              } else if (dateSlots.length === 1) {
                state.context = trackOfferedSlots(state.context, [dateSlots[0]], true);
                const dayName = new Intl.DateTimeFormat("en-US", {
                  weekday: "long",
                  timeZone: env.GOOGLE_TIMEZONE
                }).format(requestedDate);
                const monthName = new Intl.DateTimeFormat("en-US", {
                  month: "long",
                  timeZone: env.GOOGLE_TIMEZONE
                }).format(requestedDate);
                reply = `I have ${dayName}, ${monthName} ${requestedDate.getUTCDate()} at ${dateSlots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1]}. Does that work?`;
              } else {
                console.log(`[Date Request] No slots on requested date, offering alternatives`);
                const altSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                  daysPrimary: 7,
                  daysFallback: 14
                });
                if (altSlots.length >= 2) {
                  state.context = trackOfferedSlots(state.context, altSlots, false);
                  reply = `That date is fully booked. The closest I have is ${reClose(altSlots, psid)}`;
                } else {
                  reply = "That date is fully booked. What other day works for you?";
                }
              }
              console.log(`[Date Request] \u2705 Date handled - skipping slot matching`);
            } else {
              const match = tryMatchSlot(text, slots);
              if (match?.requiresChoice) {
                console.log("[CHOICE REQUIRED] User needs to pick between 2 slots");
                const time1 = slots[0].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || slots[0].label;
                const time2 = slots[1].label.match(/(\d{1,2}:\d{2}\s*(?:AM|PM))/i)?.[1] || slots[1].label;
                reply = `Great! Which time works better \u2014 1 for ${time1} or 2 for ${time2}?`;
              } else if (match?.matched && match.slot) {
                console.log("[BOOKING] User selected slot:", match.slot.label);
                console.log("[BOOKING] Checking if slot is still available...");
                const stillFree = await gcal.isSlotStillFree(match.slot);
                console.log("[BOOKING] Slot availability:", stillFree);
                if (!stillFree) {
                  console.log("[BOOKING] Slot is no longer available, generating new slots");
                  const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                    daysPrimary: 7,
                    daysFallback: 14
                  });
                  state.context.slots = newSlots;
                  reply = `That slot is no longer available. ${reClose(newSlots, psid)}`;
                } else {
                  console.log("[BOOKING] Slot is free, claiming as pending...");
                  const claimed = await repo.tryClaimPendingSlot(lead.id, match.slot);
                  if (!claimed) {
                    console.log("[BOOKING] Already has pending/booked slot");
                    const freshLead = await repo.getLeadById(lead.id);
                    if (freshLead.pending_slot_label) {
                      reply = `I'm holding ${freshLead.pending_slot_label} for you. What's the service address?`;
                      state.step = "post_book_collect";
                      state.context.collectStep = "address";
                    } else if (freshLead.booked_slot_label) {
                      reply = `You're already booked for ${freshLead.booked_slot_label}. Need to change it?`;
                      state.step = "post_book_collect";
                      state.context.collectStep = "done";
                    } else {
                      const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                        daysPrimary: 7,
                        daysFallback: 14
                      });
                      state.context.slots = newSlots;
                      reply = reClose(newSlots, psid);
                    }
                  } else {
                    console.log("[BOOKING] Pending claim succeeded, collecting details...");
                    state.step = "post_book_collect";
                    state.context.collectStep = "address";
                    reply = claimedAskAddress(match.slot.label, psid);
                    try {
                      await repo.trackEvent(lead.id, "slot_claimed_pending", {
                        slot: match.slot.label
                      });
                    } catch (analyticsError) {
                      console.error("[Analytics] Failed to track pending claim:", analyticsError);
                    }
                  }
                }
              } else {
                const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
                const normalizedText = text.toLowerCase().trim();
                let mentionedDay = null;
                for (const day of dayNames) {
                  if (normalizedText.includes(day)) {
                    mentionedDay = day;
                    console.log(`[Day Detection] Found day name: ${mentionedDay}`);
                    break;
                  }
                }
                if (mentionedDay) {
                  state.context = trackRequestedDay(state.context, mentionedDay);
                  state.context = trackIntent(state.context, "day_request");
                  const hasDay = slots.some((s) => s.label.toLowerCase().includes(mentionedDay));
                  if (!hasDay) {
                    console.log(`[Day Request] User wants ${mentionedDay}, checking availability`);
                    console.log(`[Day Request] Current slots:`, slots?.map((s) => s.label));
                    const excludeDays = getExcludedDays(state.context);
                    console.log(`[Day Request] Excluded days:`, excludeDays);
                    console.log(`[Day Request] Generating extended slots (14 days) WITHOUT excluding ${mentionedDay}`);
                    const extendedSlots = await gcal.generateTwoSlotsFixedWindows(14, [], 999);
                    console.log(`[Day Request] Extended slots:`, extendedSlots?.map((s) => s.label));
                    console.log(`[Day Request] Extended slots count:`, extendedSlots?.length);
                    let daySlots = extendedSlots.filter(
                      (s) => s.label.toLowerCase().includes(mentionedDay)
                    );
                    const seen = /* @__PURE__ */ new Set();
                    daySlots = daySlots.filter((s) => {
                      const key = `${s.startISO}|${s.endISO}`;
                      if (seen.has(key)) return false;
                      seen.add(key);
                      return true;
                    });
                    console.log(`[Day Request] Found ${daySlots.length} slots for ${mentionedDay}`);
                    console.log(`[Day Request] Day slots:`, daySlots?.map((s) => s.label));
                    if (daySlots.length >= 2) {
                      console.log(`[Day Request] SUCCESS - Found 2+ slots for ${mentionedDay}`);
                      state.context = trackOfferedSlots(state.context, daySlots.slice(0, 2), true);
                      reply = dayClose(mentionedDay, state.context.slots, psid);
                    } else if (daySlots.length === 1) {
                      console.log(`[Day Request] PARTIAL - Found 1 slot for ${mentionedDay}`);
                      const otherSlot = extendedSlots.find(
                        (s) => !s.label.toLowerCase().includes(mentionedDay)
                      );
                      if (otherSlot) {
                        state.context = trackOfferedSlots(state.context, [daySlots[0], otherSlot], true);
                        reply = `I have one ${mentionedDay} slot available. ${reClose(state.context.slots)}`;
                      } else {
                        state.context = trackOfferedSlots(state.context, [daySlots[0]], true);
                        reply = `I have ${daySlots[0].label} available. Does that work?`;
                      }
                    } else {
                      console.log(`[Day Request] FAILED - No slots found for ${mentionedDay}`);
                      console.log(`[Day Request] ${mentionedDay} not available, generating fresh slots`);
                      const excludeDaysWithRequested = [...excludeDays, mentionedDay];
                      console.log(`[Day Request] Excluding days:`, excludeDaysWithRequested);
                      const freshSlots = await gcal.generateTwoSlotsFixedWindows(14, excludeDaysWithRequested, 2);
                      console.log(`[Day Request] Fresh slots:`, freshSlots?.map((s) => s.label));
                      if (freshSlots.length >= 2) {
                        state.context = trackOfferedSlots(state.context, freshSlots, false);
                        reply = `I don't have ${mentionedDay} available. How about ${reClose(freshSlots)}`;
                      } else if (freshSlots.length === 1) {
                        state.context = trackOfferedSlots(state.context, [freshSlots[0]], false);
                      } else {
                        if (shouldAskOpenEnded(state.context)) {
                          reply = `What day works best for you? I'll check my calendar and find the best times.`;
                        } else {
                          reply = `I don't have ${mentionedDay} available. What other day works for you?`;
                        }
                      }
                    }
                  } else {
                    reply = `Which time on ${mentionedDay}? Reply with 1 or 2.`;
                  }
                } else {
                  const qType2 = detectQuestionType(text);
                  console.log("[Question] Detected type:", qType2, "for text:", text);
                  if (qType2 === "availability") {
                    console.log("[Availability] User asking about other times, generating fresh slots");
                    state.context = trackIntent(state.context, "availability_question");
                    const excludeDays = getExcludedDays(state.context);
                    const newSlots = await gcal.generateTwoSlotsFixedWindows(14, excludeDays, 2);
                    if (newSlots.length >= 2) {
                      state.context = trackOfferedSlots(state.context, newSlots);
                      reply = `Sure! ${reClose(newSlots)}`;
                    } else {
                      reply = "What day works best for you?";
                    }
                  } else if (qType2 !== "unknown") {
                    state.context = trackIntent(state.context, `faq_${qType2}`);
                    let slotLabels;
                    if (slots.length >= 2) {
                      slotLabels = [slots[0].label, slots[1].label];
                    } else if (slots.length === 1) {
                      slotLabels = [slots[0].label, slots[0].label];
                    } else {
                      const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                        daysPrimary: 7,
                        daysFallback: 14
                      });
                      state.context.slots = newSlots;
                      slotLabels = newSlots.length >= 2 ? [newSlots[0].label, newSlots[1].label] : ["available time", "available time"];
                    }
                    console.log("[DeepSeek] Calling API for FAQ with exactly 2 slots:", slotLabels);
                    try {
                      reply = await deepSeekAnswer({
                        env,
                        question: text,
                        serviceName: env.SERVICE_NAME,
                        servicePrice: env.SERVICE_PRICE,
                        addons,
                        slotLabels
                        // Always exactly 2
                      });
                      console.log("[DeepSeek] SUCCESS:", reply.substring(0, 100) + "...");
                    } catch (e) {
                      console.error("[DeepSeek] FAILED:", e);
                      const answer = answerQuestion(env, qType2, addons);
                      reply = `${answer} ${reClose(slots)}`;
                      console.log("[DeepSeek] Using fallback response");
                    }
                  } else if (normalizedText.includes("works") || normalizedText.includes("good") || normalizedText.includes("fine")) {
                    state.context = trackIntent(state.context, "ambiguous_confirmation");
                    reply = `Great! Which one? Reply with 1 for ${slots[0].label} or 2 for ${slots[1].label}.`;
                  } else {
                    console.log("[Unknown] Using reClose");
                    state.context = trackIntent(state.context, "unknown");
                    reply = reClose(slots, psid);
                  }
                }
              }
            }
          }
        } else if (state.step === "post_book_collect") {
          if (detectStop(text)) {
            await repo.setLeadStatus(lead.id, "dead");
            reply = stopResponse();
          } else if (detectHuman(text)) {
            await repo.setLeadStatus(lead.id, "needs_followup");
            reply = humanResponse();
          } else if (detectChangeRequest(text)) {
            console.log("[CHANGE] User requesting to change booking");
            const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
            const normalizedText = text.toLowerCase().trim();
            let mentionedDay = null;
            for (const day of dayNames) {
              if (normalizedText.includes(day)) {
                mentionedDay = day;
                break;
              }
            }
            await repo.releaseBookingClaim(lead.id);
            await repo.setLeadStatus(lead.id, "active");
            state.step = "closing";
            state.context.collectStep = void 0;
            state.context.name = void 0;
            state.context.address = void 0;
            if (mentionedDay) {
              console.log(`[CHANGE] User wants ${mentionedDay}`);
              state.context = trackRequestedDay(state.context, mentionedDay);
              const excludeDays = getExcludedDays(state.context);
              const extendedSlots = await gcal.generateTwoSlotsFixedWindows(14, [], 999);
              const daySlots = extendedSlots.filter(
                (s) => s.label.toLowerCase().includes(mentionedDay)
              );
              if (daySlots.length >= 2) {
                state.context = trackOfferedSlots(state.context, daySlots.slice(0, 2));
                reply = `No problem! For ${mentionedDay}, ${reClose(state.context.slots)}`;
              } else if (daySlots.length === 1) {
                const otherSlot = extendedSlots.find(
                  (s) => !s.label.toLowerCase().includes(mentionedDay)
                );
                if (otherSlot) {
                  state.context = trackOfferedSlots(state.context, [daySlots[0], otherSlot]);
                  reply = `No problem! I have one ${mentionedDay} slot. ${reClose(state.context.slots)}`;
                } else {
                  state.context = trackOfferedSlots(state.context, [daySlots[0]]);
                  reply = `No problem! I have ${daySlots[0].label} available. Does that work?`;
                }
              } else {
                const freshSlots = await gcal.generateTwoSlotsFixedWindows(14, excludeDays, 2);
                if (freshSlots.length >= 2) {
                  state.context = trackOfferedSlots(state.context, freshSlots);
                  reply = `No problem! I don't have ${mentionedDay} available. How about ${reClose(freshSlots)}`;
                } else {
                  reply = "No problem! What day works best for you?";
                }
              }
            } else {
              const excludeDays = getExcludedDays(state.context);
              const newSlots = await gcal.generateTwoSlotsFixedWindows(14, excludeDays, 2);
              if (newSlots.length >= 2) {
                state.context = trackOfferedSlots(state.context, newSlots);
                reply = `No problem, we can adjust your appointment. ${reClose(newSlots)}`;
              } else {
                reply = "No problem! What day works best for you?";
              }
            }
          } else {
            const slots = state.context.slots ?? [];
            const match = tryMatchSlot(text, slots);
            if (match?.matched && match.slot) {
              const freshLead = await repo.getLeadById(lead.id);
              if (freshLead.pending_slot_label) {
                reply = `I'm already holding ${freshLead.pending_slot_label} for you. What's the service address?`;
                state.context.collectStep = "address";
              } else if (freshLead.booked_slot_label) {
                reply = `You're already booked for ${freshLead.booked_slot_label}. What's the address and phone for the service?`;
                state.context.collectStep = state.context.collectStep ?? "address";
              } else {
                reply = "What's the service address?";
                state.context.collectStep = "address";
              }
            } else {
              const qType = detectQuestionType(text);
              if (qType !== "unknown") {
                const answer = answerQuestion(env, qType, addons);
                reply = `${answer} If you need to change it, tell me and I'll adjust`;
              } else {
                const collectStep = state.context.collectStep ?? "address";
                if (collectStep === "address") {
                  state.context.address = text;
                  state.context.collectStep = "phone";
                  reply = collectedAddressAskPhone(psid);
                } else if (collectStep === "phone") {
                  console.log("[BOOKING] ========== PHONE COLLECTION STARTED ==========");
                  console.log("[BOOKING] collectStep:", state.context.collectStep);
                  console.log("[BOOKING] address:", state.context.address);
                  console.log("[BOOKING] phone (user input):", text);
                  console.log("[BOOKING] lead.id:", lead.id);
                  console.log("[BOOKING] psid:", psid);
                  state.context.phone = text;
                  console.log("[BOOKING] All details collected, starting finalization...");
                  console.log("[BOOKING] Step 1: Retrieving pending slot...");
                  console.log("[BOOKING] Calling repo.getPendingSlot() for lead:", lead.id);
                  const pending = await repo.getPendingSlot(lead.id);
                  console.log("[BOOKING] Pending slot result:", pending ? {
                    label: pending.label,
                    startISO: pending.startISO,
                    endISO: pending.endISO,
                    claimedAt: pending.claimedAt,
                    ageMinutes: pending.claimedAt ? (((/* @__PURE__ */ new Date()).getTime() - new Date(pending.claimedAt).getTime()) / (1e3 * 60)).toFixed(1) : "unknown"
                  } : "NULL (expired or missing)");
                  if (!pending) {
                    console.log("[BOOKING] \u26A0\uFE0F No pending slot found - expired or missing");
                    console.log("[BOOKING] Releasing pending claim and restarting flow...");
                    await repo.releasePendingClaim(lead.id);
                    const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                      daysPrimary: 7,
                      daysFallback: 14
                    });
                    state.context.slots = newSlots;
                    state.step = "closing";
                    state.context.collectStep = void 0;
                    reply = pendingExpired(newSlots, psid);
                    console.log("[BOOKING] Flow restarted with new slots");
                  } else {
                    if (!pending.label || !pending.startISO || !pending.endISO) {
                      console.error("[BOOKING] \u26A0\uFE0F Invalid pending slot data structure:", {
                        hasLabel: !!pending.label,
                        hasStartISO: !!pending.startISO,
                        hasEndISO: !!pending.endISO,
                        pending
                      });
                      await repo.releasePendingClaim(lead.id);
                      const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                        daysPrimary: 7,
                        daysFallback: 14
                      });
                      state.context.slots = newSlots;
                      state.step = "closing";
                      state.context.collectStep = void 0;
                      reply = pendingExpired(newSlots, psid);
                      console.log("[BOOKING] Flow restarted due to invalid pending slot data");
                    } else {
                      console.log("[BOOKING] \u2705 Pending slot data validated");
                      if (!state.context.address || !state.context.phone) {
                        console.error("[BOOKING] \u26A0\uFE0F Missing customer details:", {
                          hasAddress: !!state.context.address,
                          hasPhone: !!state.context.phone
                        });
                        if (!state.context.address) {
                          state.context.collectStep = "address";
                          reply = "I'm missing your address. What's the service address?";
                        } else {
                          state.context.collectStep = "phone";
                          reply = "I'm missing your phone number. What's the best number to reach you?";
                        }
                      } else {
                        console.log("[BOOKING] \u2705 Customer details validated");
                        console.log("[BOOKING] Step 2: Checking if slot still free...");
                        console.log("[BOOKING] Slot to check:", {
                          label: pending.label,
                          startISO: pending.startISO,
                          endISO: pending.endISO
                        });
                        const stillFree = await gcal.isSlotStillFree({
                          label: pending.label,
                          startISO: pending.startISO,
                          endISO: pending.endISO
                        });
                        console.log("[BOOKING] Staleness check result:", stillFree ? "\u2705 STILL FREE" : "\u274C TAKEN");
                        if (!stillFree) {
                          console.log("[BOOKING] \u26A0\uFE0F Pending slot no longer available, restarting");
                          await repo.releasePendingClaim(lead.id);
                          const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                            daysPrimary: 7,
                            daysFallback: 14
                          });
                          state.context.slots = newSlots;
                          state.step = "closing";
                          state.context.collectStep = void 0;
                          reply = pendingExpired(newSlots, psid);
                          console.log("[BOOKING] Flow restarted with new slots");
                        } else {
                          console.log("[BOOKING] Step 3: Creating calendar event...");
                          console.log("[BOOKING] Event details:", {
                            slot: {
                              label: pending.label,
                              startISO: pending.startISO,
                              endISO: pending.endISO
                            },
                            summary: env.SERVICE_NAME,
                            customerAddress: state.context.address,
                            customerPhone: state.context.phone,
                            psid
                          });
                          try {
                            const customerDetails = `Address: ${state.context.address}
Phone: ${state.context.phone}
PSID: ${psid}`;
                            console.log("[BOOKING] Calling gcal.createEvent()...");
                            const eventId = await gcal.createEvent(
                              {
                                label: pending.label,
                                startISO: pending.startISO,
                                endISO: pending.endISO
                              },
                              env.SERVICE_NAME,
                              customerDetails
                            );
                            console.log("[BOOKING] \u2705 Calendar event created successfully!");
                            console.log("[BOOKING] Event ID:", eventId);
                            console.log("[BOOKING] Event ID type:", typeof eventId);
                            console.log("[BOOKING] Event ID length:", eventId?.length);
                            if (!eventId || typeof eventId !== "string" || eventId.length === 0) {
                              console.error("[BOOKING] \u26A0\uFE0F Invalid event ID returned from Google Calendar API:", {
                                eventId,
                                type: typeof eventId,
                                length: eventId?.length
                              });
                              throw new Error("Invalid event ID from Google Calendar API");
                            }
                            console.log("[BOOKING] \u2705 Event ID validated");
                            console.log("[BOOKING] Step 4: Finalizing booking in database...");
                            console.log("[BOOKING] Finalization params:", {
                              leadId: lead.id,
                              eventId,
                              address: state.context.address,
                              phone: state.context.phone
                            });
                            await repo.finalizeBookingWithDetails(lead.id, eventId, {
                              address: state.context.address,
                              phone: state.context.phone
                            });
                            console.log("[BOOKING] \u2705 Booking finalized in database successfully!");
                            console.log("[BOOKING] ========== BOOKING COMPLETE ==========");
                            try {
                              console.log("[EMAIL] Sending chatbot booking notification...");
                              await sendChatbotBookingEmail(env, {
                                slotLabel: pending.label,
                                address: state.context.address,
                                phone: state.context.phone,
                                psid,
                                eventId
                              });
                            } catch (emailError) {
                              console.error("[EMAIL] Failed to send notification:", emailError);
                            }
                            try {
                              await repo.trackEvent(lead.id, "booking_completed", {
                                slot: pending.label,
                                eventId,
                                address: state.context.address,
                                phone: state.context.phone
                              });
                            } catch (analyticsError) {
                              console.error("[Analytics] Failed to track booking:", analyticsError);
                            }
                            console.log("[BOOKING] Disabling bot for this lead - human takeover");
                            await repo.disableBot(lead.id);
                            console.log("[BOOKING] Resetting conversation state for fresh start");
                            state.step = "start";
                            state.context = initializeContext({});
                            reply = finalizedBooking(pending.label, psid);
                          } catch (eventError) {
                            console.error("[BOOKING] \u274C\u274C\u274C EVENT CREATION FAILED \u274C\u274C\u274C");
                            console.error("[BOOKING] Error type:", eventError?.constructor?.name);
                            console.error("[BOOKING] Error message:", eventError?.message);
                            console.error("[BOOKING] Error stack:", eventError?.stack);
                            try {
                              console.error("[BOOKING] Full error object:", JSON.stringify(eventError, Object.getOwnPropertyNames(eventError), 2));
                            } catch (stringifyError) {
                              console.error("[BOOKING] Could not stringify error:", eventError);
                            }
                            console.error("[BOOKING] Failed request details:", {
                              slot: {
                                label: pending.label,
                                startISO: pending.startISO,
                                endISO: pending.endISO
                              },
                              summary: env.SERVICE_NAME,
                              hasCustomerDetails: !!(state.context.address && state.context.phone)
                            });
                            await repo.releasePendingClaim(lead.id);
                            const newSlots = await gcal.generateTwoSlots(env.GOOGLE_TIMEZONE, {
                              daysPrimary: 7,
                              daysFallback: 14
                            });
                            state.context.slots = newSlots;
                            state.step = "closing";
                            state.context.collectStep = void 0;
                            reply = `Sorry \u2014 that slot got taken. ${reClose(newSlots, psid)}`;
                            console.log("[BOOKING] Flow restarted after event creation failure");
                          }
                        }
                      }
                    }
                  }
                } else {
                  reply = "Got it. If you need to change it, tell me and I'll adjust.";
                }
              }
            }
          }
        }
        await repo.upsertConvoState(lead.id, state.step, state.context);
        const logPayload = {
          psid,
          step: state.step,
          dedupeKey,
          mid: ev.message?.mid ?? null,
          send_payload: { text: reply }
        };
        if (state.context.slots && Array.isArray(state.context.slots)) {
          logPayload.slots = state.context.slots.map((s) => s.label);
        }
        await repo.insertOutboundMessage(lead.id, reply, logPayload);
        try {
          await repo.saveConversationHistory(lead.id, "assistant", reply);
        } catch (historyError) {
          console.error("[History] Failed to save assistant response:", historyError);
        }
        try {
          if (state.context.lastIntent) {
            await repo.saveIntent(lead.id, text, state.context.lastIntent);
          }
        } catch (intentError) {
          console.error("[Intent] Failed to save:", intentError);
        }
        try {
          if (state.context.slots && state.step === "closing") {
            await repo.trackEvent(lead.id, "slots_offered", {
              slots: state.context.slots.map((s) => s.label),
              attemptCount: state.context.attemptCount || 0
            });
          }
        } catch (analyticsError) {
          console.error("[Analytics] Failed to track slots offered:", analyticsError);
        }
        await sendTextMessage(psid, reply, env.FB_PAGE_ACCESS_TOKEN);
      } catch (err) {
        console.error("Processing error:", err);
        const fallback = "Sorry \u2014 something went wrong. What day/time works for you?";
        try {
          const lead = await repo.upsertLeadByPsid(ev.sender?.id);
          await repo.insertOutboundMessage(lead.id, fallback, {
            psid: ev.sender?.id,
            error: String(err)
          });
          await sendTextMessage(ev.sender?.id, fallback, env.FB_PAGE_ACCESS_TOKEN);
        } catch (sendError) {
          console.error("Failed to send error message:", sendError);
        }
      }
    }
  }
}
__name(processPayload, "processPayload");
export {
  index_default as default
};
//# sourceMappingURL=index.js.map
